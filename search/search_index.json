{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PhotoScript's Documentation","text":""},{"location":"#source-code","title":"Source Code","text":"<p>The source code for this project is available on GitHub.</p>"},{"location":"#what-is-photoscript","title":"What is PhotoScript","text":"<p>PhotoScript provides a python wrapper around Apple Photos applescript interface.  With PhotoScript you can interact with Photos using python.  Runs only on MacOS.  Tested on MacOS Catalina.</p> <p>PhotosScript is limited by Photos' very limited AppleScript dictionary.</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>Designed for MacOS Catalina/Photos 5.  Preliminary testing on Big Sur/Photos 6 beta shows this should work on Big Sur as well.  Photos' AppleScript interface has changed very little since Photos 2 (the earliest version I have access to).  This package should work with most versions of Photos but some methods may not function correctly on versions earlier than Photos 5.  If you find compatibility issues, open an issue or send a PR.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install via pip:</p> <p><code>python3 -m pip install photoscript</code></p> <p>To install via the source code:</p> <ul> <li>Install uv if not already installed</li> <li>Clone the repo: <code>git clone git@github.com:RhetTbull/PhotoScript.git</code></li> <li>Change to the directory: <code>cd PhotoScript</code></li> <li>Run <code>uv pip install -r pyproject.toml</code>.</li> </ul> <p>If you want to develop code for PhotoScript, see README_DEV.md.</p>"},{"location":"#example","title":"Example","text":"<pre><code>\"\"\" Simple example showing use of photoscript \"\"\"\n\nimport photoscript\n\nphotoslib = photoscript.PhotosLibrary()\n\nphotoslib.activate()\nprint(f\"Running Photos version: {photoslib.version}\")\n\nalbum = photoslib.album(\"Album1\")\nphotos = album.photos()\n\nfor photo in photos:\n    photo.keywords = [\"travel\", \"vacation\"]\n    print(f\"{photo.title}, {photo.description}, {photo.keywords}\")\n\nnew_album = photoslib.create_album(\"New Album\")\nphotoslib.import_photos([\"/Users/rhet/Downloads/test.jpeg\"], album=new_album)\n\nphotoslib.quit()\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation here.</p> <p>Additional documentation about Photos and AppleScript available on the wiki.</p>"},{"location":"#testing","title":"Testing","text":"<p>Tested on MacOS Catalina, Photos 5 with 100% coverage.</p>"},{"location":"#limitations","title":"Limitations","text":"<p>Photos' AppleScript interface is very limited.  For example, it cannot access information on faces in photos nor can it delete a photo.  PhotoScript is thus limited.  PhotoScript works by executing AppleScript through an Objective-C bridge from python.  Every method call has to do a python-&gt;Objective C-&gt;AppleScript round trip; this makes the interface much slower than native python code.  This is particularly noticeable when dealing with Folders which requires significant work arounds.</p> <p>Where possible, PhotoScript attempts to provide work-arounds to Photos' limitations. For example, Photos does not provide a way to remove a photo from an album.  PhotoScript does provide a <code>Album.remove()</code> method but in order to do this, it creates a new album with the same name as the original, copies all but the removed photos to the new album then deletes the original album.  This simulates removing photos and produces the desired effect but is not the same thing as removing a photo from an album.</p>"},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>OSXPhotos: Python app to work with pictures and associated metadata from Apple Photos on macOS. Also includes a package to provide programmatic access to the Photos library, pictures, and metadata.</li> <li>PhotoKit: Experimental Python package for accessing the macOS Photos.app library via Apple's native PhotoKit framework.</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li>py-applescript</li> <li>PyObjC</li> </ul>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#photoslibrary","title":"PhotosLibrary","text":"Source code in <code>photoscript/__init__.py</code> <pre><code>class PhotosLibrary:\n    def __init__(self):\n        \"\"\"create new PhotosLibrary object and launch Photos\"\"\"\n        run_script(\"photosLibraryWaitForPhotos\", 300)\n        self._version = str(run_script(\"photosLibraryVersion\"))\n\n    def activate(self):\n        \"\"\"activate Photos.app\"\"\"\n        run_script(\"photosLibraryActivate\")\n\n    def quit(self):\n        \"\"\"quit Photos.app\"\"\"\n        run_script(\"photosLibraryQuit\")\n\n    def open(self, library_path, delay=10):\n        \"\"\"open a library and wait for delay for user to acknowledge in Photos\"\"\"\n        # Note: Unlike the other AppleScript scripts, this one is not included in photoscript.applescript\n        # because, for reasons I cannot explain, it fails to run if included there\n        if not pathlib.Path(library_path).is_dir():\n            raise ValueError(f\"{library_path} does not appear to be a Photos library\")\n        self.activate()\n        script = AppleScript(\n            f\"\"\"\n            set tries to 0\n            repeat while tries &lt; 5\n                try\n                    tell application \"Photos\"\n                        activate\n                        delay 3 \n                        open POSIX file \"{library_path}\"\n                        delay {delay}\n                    end tell\n                    set tries to 5\n                on error\n                    set tries to tries + 1\n                end try\n            end repeat\n        \"\"\"\n        )\n        script.run()\n\n    @property\n    def running(self):\n        \"\"\"True if Photos is running, otherwise False\"\"\"\n        return run_script(\"photosLibraryIsRunning\")\n\n    def hide(self):\n        \"\"\"Tell Photos to hide its window\"\"\"\n        run_script(\"photosLibraryHide\")\n\n    @property\n    def hidden(self):\n        \"\"\"True if Photos is hidden (or not running), False if Photos is visible\"\"\"\n        return run_script(\"photosLibraryIsHidden\")\n\n    @property\n    def name(self):\n        \"\"\"name of Photos.app\"\"\"\n        return run_script(\"photosLibraryName\")\n\n    @property\n    def version(self):\n        \"\"\"version of Photos.app as str\"\"\"\n        return self._version\n\n    @property\n    def frontmost(self):\n        \"\"\"True if Photos.app is front most app otherwise False\"\"\"\n        return run_script(\"photosLibraryIsFrontMost\")\n\n    @property\n    def selection(self):\n        \"\"\"List of Photo objects for currently selected photos or [] if no selection\"\"\"\n        uuids = run_script(\"photosLibraryGetSelection\")\n        return [Photo(uuid) for uuid in uuids]\n\n    @property\n    def favorites(self):\n        \"\"\"Album object for the Favorites album\"\"\"\n        fav_id = run_script(\"photosLibraryFavorites\")\n        return Album(fav_id)\n\n    # doesn't seem to be a way to do anything with the recently deleted album except count items\n    # @property\n    # def recently_deleted(self):\n    #     \"\"\" Album object for the Recently Deleted album \"\"\"\n    #     del_id = run_script(\"photosLibraryRecentlyDeleted\")\n    #     return Album(del_id)\n\n    def photos(self, search=None, uuid=None, range_=None):\n        \"\"\"Returns a generator that yields Photo objects for media items in the library.\n\n        Args:\n            search: optional text string to search for (returns matching items)\n            uuid: optional list of UUIDs to get\n            range: optional list of [start, stop] sequence of photos to get\n\n        Returns:\n            Generator that yields Photo objects\n\n        Raises:\n            ValueError if more than one of search, uuid, range passed or invalid range\n            TypeError if list not passed for range\n\n        Note: photos() returns a generator instead of a list because retrieving all the photos\n        from a large Photos library can take a very long time--on my system, the rate is about 1\n        per second; this is limited by the Photos AppleScript interface and I've not found\n        anyway to speed it up.  Using a generator allows you process photos individually rather\n        than waiting, possibly hours, for Photos to return the results.\n\n        range works like python's range function.  Thus range=[0,4] will return\n        Photos 0, 1, 2, 3; range=[10] returns the first 10 photos in the library;\n        range start must be in range 0 to len(PhotosLibrary())-1,\n        stop in range 1 to len(PhotosLibrary()).  You may be able to optimize the speed by which\n        photos are return by chunking up requests in batches of photos using range,\n        e.g. request 10 photos at a time.\n        \"\"\"\n        if len([x for x in [search, uuid, range_] if x]) &gt; 1:\n            raise ValueError(\"Cannot pass more than one of search, uuid, range_\")\n\n        if not any([search, uuid, range_]):\n            return self._iterphotos()\n\n        if search is not None:\n            # search for text\n            photo_ids = run_script(\"photosLibrarySearchPhotos\", search)\n        elif uuid:\n            # search by uuid\n            photo_ids = uuid\n        else:\n            # search by range\n            if not isinstance(range_, list):\n                raise TypeError(\"range_ must be a list\")\n\n            if not (1 &lt;= len(range_) &lt;= 2):\n                raise ValueError(\"invalid range, must be list of len 1 or 2\")\n\n            if len(range_) == 1:\n                start = 0\n                stop = range_[0]\n            else:\n                start, stop = range_\n\n            if start &gt; stop:\n                raise ValueError(\"start range must be &lt;= stop range\")\n\n            count = len(self)\n            if not ((0 &lt;= start &lt;= count - 1) and (1 &lt;= stop &lt;= count)):\n                raise ValueError(\n                    f\"invalid range: valid range is start: 0 to {count-1}, stop: 1 to {count}\"\n                )\n\n            photo_ids = run_script(\"photosLibraryGetPhotoByRange\", start + 1, stop)\n\n        return self._iterphotos(uuids=photo_ids) if photo_ids else []\n\n    def _iterphotos(self, uuids=None):\n        if uuids:\n            for uuid in uuids:\n                yield Photo(uuid)\n        else:\n            # return all photos via generator\n            count = len(self)\n            for x in range(1, count + 1):\n                # AppleScript list indexes start at 1\n                photo_id = run_script(\"photosLibraryGetPhotoByRange\", x, x)[0]\n                yield Photo(photo_id)\n\n    def import_photos(self, photo_paths, album=None, skip_duplicate_check=False):\n        \"\"\"import photos\n\n        Args:\n            photo_paths: list of file paths to import as str or pathlib.Path\n            album: optional, Album object for album to import into\n            skip_duplicate_check: if True, Photos will not check for duplicates on import, default is False.\n\n        Returns:\n            list of Photo objects for imported photos\n\n        NOTE: If you attempt to import a duplicate photo and skip_duplicate_check != True,\n            Photos will block with drop-down sheet until the user clicks \"Cancel, Import, or Don't Import.\"\n        \"\"\"\n        # stringify paths in case pathlib.Path paths are passed\n        photo_paths = [str(photo_path) for photo_path in photo_paths]\n        if album is not None:\n            photo_ids = run_script(\n                \"photosLibraryImportToAlbum\",\n                photo_paths,\n                album.id,\n                skip_duplicate_check,\n            )\n        else:\n            photo_ids = run_script(\n                \"photosLibraryImport\", photo_paths, skip_duplicate_check\n            )\n\n        return [Photo(photo) for photo in photo_ids]\n\n    def album_names(self, top_level=False):\n        \"\"\"List of album names in the Photos library\n\n        Args:\n            top_level: if True, returns only top-level albums otherwise also returns albums in sub-folders; default is False\n        \"\"\"\n        return run_script(\"photosLibraryAlbumNames\", top_level)\n\n    def folder_names(self, top_level=False):\n        \"\"\"List of folder names in the Photos library\n\n        Args:\n            top_level: if True, returns only top-level folders otherwise also returns sub-folders; default is False\n        \"\"\"\n        return run_script(\"photosLibraryFolderNames\", top_level)\n\n    def album(self, *name, uuid=None, top_level=False):\n        \"\"\"Album instance by name or id\n\n        Args:\n            name: name of album\n            uuid: id of album\n            top_level: if True, searches only top level albums; default = False\n\n        Returns:\n            Album object or None if album could not be found\n\n        Raises:\n            ValueError if both name and id passed or neither passed.\n\n        Must pass only name or id but not both.\n        If more than one album with same name, returns the first one found.\n        \"\"\"\n        if (not name and uuid is None) or (name and uuid is not None):\n            raise ValueError(\"Must pass only name or uuid but not both\")\n\n        if name:\n            uuid = run_script(\"albumByName\", name[0], top_level)\n            if uuid != 0:\n                return Album(uuid)\n            else:\n                return None\n        else:\n            return Album(uuid)\n\n    def albums(self, top_level=False):\n        \"\"\"list of Album objects for all albums\"\"\"\n        album_ids = run_script(\"photosLibraryAlbumIDs\", top_level)\n        return [Album(uuid) for uuid in album_ids]\n\n    def create_album(self, name, folder: \"Folder\" = None) -&gt; \"Album\":\n        \"\"\"creates an album\n\n        Args:\n            name: name of new album\n            folder: Folder object in which to create new album.\n                    If None, creates top-level album.  Default is None.\n\n        Returns:\n            Album object for newly created album\n\n        Raises:\n            AppleScriptError if error creating the album\n        \"\"\"\n        if folder is None:\n            album_id = run_script(\"photosLibraryCreateAlbum\", name)\n        else:\n            album_id = run_script(\n                \"photosLibraryCreateAlbumAtFolder\", name, folder.idstring\n            )\n\n        if album_id != kMissingValue:\n            return Album(album_id)\n        else:\n            raise AppleScriptError(f\"Could not create album {name}\")\n\n    def delete_album(self, album: \"Album\"):\n        \"\"\"deletes album (but does not delete photos in the album)\n\n        Args:\n            album: an Album object for album to delete\n        \"\"\"\n        return run_script(\"photosLibraryDeleteAlbum\", album.id)\n\n    def folder(\n        self, name: str = None, path: list[str] = None, uuid: str = None, top_level=True\n    ):\n        \"\"\"Folder instance by name or uuid\n\n        Args:\n            name: name of folder, e.g. \"My Folder\"\n            path: path of folder as list of strings, e.g. [\"My Folder\", \"Subfolder\"]\n            uuid: id of folder, e.g. \"F1234567-1234-1234-1234-1234567890AB\"\n            top_level: if True, only searches top level folders by name; default is True\n\n        Returns:\n            Folder object or None if folder could not be found\n\n        Raises:\n            ValueError not one of name, path, or uuid is passed\n\n        Notes:\n            Must pass one of path, name, or uuid but not more than one\n            If more than one folder with same name, returns first one found.\n        \"\"\"\n        if sum(bool(x) for x in [name, path, uuid]) != 1:\n            raise ValueError(\n                \"Must pass one of name, path, or uuid but not more than one\"\n            )\n\n        if path:\n            idstring = run_script(\"folderGetIDStringFromPath\", path)\n            return Folder(idstring=idstring) if idstring != kMissingValue else None\n\n        if name:\n            idstring = run_script(\n                \"photosLibraryGetFolderIDStringForName\", name, top_level\n            )\n            return Folder(idstring=idstring) if idstring != kMissingValue else None\n\n        if uuid:\n            idstring = run_script(\n                \"photosLibraryGetFolderIDStringForID\", uuid, top_level\n            )\n            return Folder(idstring=idstring) if idstring != kMissingValue else None\n\n    def folder_by_path(self, folder_path):\n        \"\"\"Return folder in the library by path\n\n        Args:\n            folder_path: list of folder names in descending path order, e.g. [\"Folder\", \"SubFolder1\", \"SubFolder2\"]\n\n        Returns:\n            Folder object for folder at folder_path or None if not found\n        \"\"\"\n        folder_id = run_script(\"folderIDByPath\", folder_path)\n        return Folder(folder_id) if folder_id != kMissingValue else None\n\n    def folders(self, top_level=True):\n        \"\"\"list of Folder objects for all folders\"\"\"\n        folder_ids = run_script(\"photosLibraryFolderIDs\", top_level)\n        return [Folder(uuid) for uuid in folder_ids]\n\n    def create_folder(self, name: str, folder: \"Folder\" = None) -&gt; \"Folder\":\n        \"\"\"creates a folder\n\n        Args:\n            name: name of new folder\n            folder: Folder object in which to create the new folder.\n                    If None, creates top-level folder. Default is None.\n\n        Returns:\n            Folder object for newly created folder\n\n        Raises:\n            AppleScriptError if folder cannot be created\n        \"\"\"\n        if folder is None:\n            folder_id = run_script(\"photosLibraryCreateFolder\", name)\n        else:\n            folder_id = run_script(\n                \"photosLibraryCreateFolderAtFolder\", name, folder.idstring\n            )\n\n        if folder_id != kMissingValue:\n            return Folder(idstring=folder_id)\n        else:\n            raise AppleScriptError(f\"Could not create folder {name}\")\n\n    def make_folders(self, folder_path):\n        \"\"\"Recursively makes folders and subfolders.  Works similar to os.makedirs_.\n        If any component of folder_path already exists, does not raise error.\n\n        .. _os.makedirs: https://docs.python.org/3/library/os.html#os.makedirs\n\n        Args:\n            folder_path: list of folder names in descending path order, e.g. [\"Folder\", \"SubFolder1\", \"SubFolder2\"]\n\n        Returns:\n            Folder object for the final sub folder\n\n        Raises:\n            ValueError if folder_path is empty\n            TypeError if folder_path is not a list\n        \"\"\"\n        if not isinstance(folder_path, list):\n            raise TypeError(\"list expected for folder_path\")\n        if not folder_path:\n            raise ValueError(\"no values in folder_path\")\n\n        folder = self.folder(folder_path[0], top_level=True)\n        if folder is None:\n            folder = self.create_folder(folder_path[0])\n        for subfolder_name in folder_path[1:]:\n            subfolder = folder.folder(subfolder_name)\n            if subfolder is None:\n                subfolder = folder.create_folder(subfolder_name)\n            folder = subfolder\n        return folder\n\n    def make_album_folders(self, album_name, folder_path):\n        \"\"\"Make album in a folder path.  If either the album or any component of the\n           folder path doesn't exist, it will be created.  If album or folder path\n           does exist, no duplicate is created.  Folder path is created recursively\n           if needed.\n\n        Args:\n            album_name: name of album to create.  If album already exists, returns existing album.\n            folder_path: list of folder names in descending path order, e.g. [\"Folder\", \"SubFolder1\", \"SubFolder2\"].\n\n        Returns:\n            Album object.\n\n        Raises:\n            ValueError if folder_path is empty or album_name is None.\n            TypeError if folder_path is not a list.\n        \"\"\"\n        if album_name is None or not len(album_name):\n            raise ValueError(\"album_name must not be None\")\n        if not isinstance(folder_path, list):\n            raise TypeError(\"list expected for folder_path\")\n        if not folder_path:\n            raise ValueError(\"no values in folder_path\")\n\n        folder = self.make_folders(folder_path)\n        album = folder.album(album_name)\n        if album is None:\n            album = folder.create_album(album_name)\n        return album\n\n    def delete_folder(self, folder: \"Folder\"):\n        \"\"\"Deletes folder (and all its sub-folders and albums)\n\n        Args:\n            folder: a Folder object for folder to delete\n\n        Notes:\n            On macOS 10.15 &amp; above, only top-level folders can be deleted.\n            Sub-folders cannot be deleted due to a bug in Photos' AppleScript\n            implementation.\n        \"\"\"\n        return run_script(\"photosLibraryDeleteFolder\", folder.idstring)\n\n    def __len__(self):\n        return run_script(\"photosLibraryCount\")\n\n    # TODO: add a temp_album() method that creates a temporary album\n    def _temp_album_name(self):\n        \"\"\"get a temporary album name that doesn't clash with album in the library\"\"\"\n        temp_name = self._temp_name()\n        while self.album(temp_name) is not None:\n            temp_name = self._temp_name()\n        return temp_name\n\n    def _temp_name(self):\n        ds = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n        random_str = \"\".join(\n            random.choice(string.ascii_lowercase + string.ascii_uppercase)\n            for i in range(10)\n        )\n        return f\"photoscript_{ds}_{random_str}\"\n\n    def _export_photo(\n        self,\n        photo,\n        export_path,\n        original=False,\n        overwrite=False,\n        timeout=120,\n        reveal_in_finder=False,\n    ):\n        \"\"\"Export photo to export_path\n\n        Args:\n            photo: Photo object to export\n            export_path: path to export to\n            original: if True, export original image, otherwise export current image; default = False\n            overwrite: if True, export will overwrite a file of same name as photo in export_path; default = False\n            timeout: number of seconds to wait for Photos to complete export before timing out; default = 120\n            reveal_in_finder: if True, will open Finder with exported items selected when done; default = False\n\n        Returns:\n            List of full paths of exported photos.  There may be more than one photo exported due\n            to live images and burst images.\n\n        Raises:\n            ValueError if export_path is not a valid directory\n\n        Note: Photos always exports as high-quality JPEG unless original=True.\n        If original=True, will export all burst images for burst photos and\n        live movie for live photos.  If original=False, only the primary image from a\n        burst set will be exported for burst photos and the live movie component of a\n        live image will not be exported, only the JPEG component.\n        \"\"\"\n\n        dest = pathlib.Path(export_path)\n        if not dest.is_dir():\n            raise ValueError(f\"export_path {export_path} must be a directory\")\n\n        edited = not original\n\n        tmpdir = tempfile.TemporaryDirectory(prefix=\"photoscript_\")\n\n        # export original\n        filename = run_script(\n            \"photoExport\", photo.id, tmpdir.name, original, edited, timeout\n        )\n\n        exported_paths = []\n        if filename is not None:\n            # need to find actual filename as sometimes Photos renames JPG to jpeg on export\n            # may be more than one file exported (e.g. if Live Photo, Photos exports both .jpeg and .mov)\n            # TemporaryDirectory will cleanup on return\n            files = glob.glob(os.path.join(tmpdir.name, \"*\"))\n            seen_files = {}\n            for fname in files:\n                path = pathlib.Path(fname)\n                dest_new = dest / path.name\n                if not overwrite:\n                    # ensure there are no name collisions on export\n                    try:\n                        dest_update = seen_files[path.stem]\n                    except KeyError:\n                        count = 1\n                        dest_files = findfiles(\n                            f\"{dest_new.stem}*\", str(dest_new.parent)\n                        )\n                        dest_files = [pathlib.Path(f).stem.lower() for f in dest_files]\n                        dest_update = dest_new.stem\n                        while dest_update.lower() in dest_files:\n                            dest_update = f\"{dest_new.stem} ({count})\"\n                            count += 1\n                        seen_files[path.stem] = dest_update\n                    dest_new = dest_new.parent / f\"{dest_update}{dest_new.suffix}\"\n                ditto(str(path), str(dest_new))\n                exported_paths.append(str(dest_new))\n            if reveal_in_finder:\n                run_script(\"revealInFinder\", exported_paths)\n        return exported_paths\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.favorites","title":"<code>favorites</code>  <code>property</code>","text":"<p>Album object for the Favorites album</p>"},{"location":"reference/#photoscript.PhotosLibrary.frontmost","title":"<code>frontmost</code>  <code>property</code>","text":"<p>True if Photos.app is front most app otherwise False</p>"},{"location":"reference/#photoscript.PhotosLibrary.hidden","title":"<code>hidden</code>  <code>property</code>","text":"<p>True if Photos is hidden (or not running), False if Photos is visible</p>"},{"location":"reference/#photoscript.PhotosLibrary.name","title":"<code>name</code>  <code>property</code>","text":"<p>name of Photos.app</p>"},{"location":"reference/#photoscript.PhotosLibrary.running","title":"<code>running</code>  <code>property</code>","text":"<p>True if Photos is running, otherwise False</p>"},{"location":"reference/#photoscript.PhotosLibrary.selection","title":"<code>selection</code>  <code>property</code>","text":"<p>List of Photo objects for currently selected photos or [] if no selection</p>"},{"location":"reference/#photoscript.PhotosLibrary.version","title":"<code>version</code>  <code>property</code>","text":"<p>version of Photos.app as str</p>"},{"location":"reference/#photoscript.PhotosLibrary.__init__","title":"<code>__init__()</code>","text":"<p>create new PhotosLibrary object and launch Photos</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def __init__(self):\n    \"\"\"create new PhotosLibrary object and launch Photos\"\"\"\n    run_script(\"photosLibraryWaitForPhotos\", 300)\n    self._version = str(run_script(\"photosLibraryVersion\"))\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.activate","title":"<code>activate()</code>","text":"<p>activate Photos.app</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def activate(self):\n    \"\"\"activate Photos.app\"\"\"\n    run_script(\"photosLibraryActivate\")\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.album","title":"<code>album(*name, uuid=None, top_level=False)</code>","text":"<p>Album instance by name or id</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>name of album</p> <code>()</code> <code>uuid</code> <p>id of album</p> <code>None</code> <code>top_level</code> <p>if True, searches only top level albums; default = False</p> <code>False</code> <p>Returns:</p> Type Description <p>Album object or None if album could not be found</p> <p>Must pass only name or id but not both. If more than one album with same name, returns the first one found.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def album(self, *name, uuid=None, top_level=False):\n    \"\"\"Album instance by name or id\n\n    Args:\n        name: name of album\n        uuid: id of album\n        top_level: if True, searches only top level albums; default = False\n\n    Returns:\n        Album object or None if album could not be found\n\n    Raises:\n        ValueError if both name and id passed or neither passed.\n\n    Must pass only name or id but not both.\n    If more than one album with same name, returns the first one found.\n    \"\"\"\n    if (not name and uuid is None) or (name and uuid is not None):\n        raise ValueError(\"Must pass only name or uuid but not both\")\n\n    if name:\n        uuid = run_script(\"albumByName\", name[0], top_level)\n        if uuid != 0:\n            return Album(uuid)\n        else:\n            return None\n    else:\n        return Album(uuid)\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.album_names","title":"<code>album_names(top_level=False)</code>","text":"<p>List of album names in the Photos library</p> <p>Parameters:</p> Name Type Description Default <code>top_level</code> <p>if True, returns only top-level albums otherwise also returns albums in sub-folders; default is False</p> <code>False</code> Source code in <code>photoscript/__init__.py</code> <pre><code>def album_names(self, top_level=False):\n    \"\"\"List of album names in the Photos library\n\n    Args:\n        top_level: if True, returns only top-level albums otherwise also returns albums in sub-folders; default is False\n    \"\"\"\n    return run_script(\"photosLibraryAlbumNames\", top_level)\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.albums","title":"<code>albums(top_level=False)</code>","text":"<p>list of Album objects for all albums</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def albums(self, top_level=False):\n    \"\"\"list of Album objects for all albums\"\"\"\n    album_ids = run_script(\"photosLibraryAlbumIDs\", top_level)\n    return [Album(uuid) for uuid in album_ids]\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.create_album","title":"<code>create_album(name, folder=None)</code>","text":"<p>creates an album</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>name of new album</p> required <code>folder</code> <code>'Folder'</code> <p>Folder object in which to create new album.     If None, creates top-level album.  Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Album'</code> <p>Album object for newly created album</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def create_album(self, name, folder: \"Folder\" = None) -&gt; \"Album\":\n    \"\"\"creates an album\n\n    Args:\n        name: name of new album\n        folder: Folder object in which to create new album.\n                If None, creates top-level album.  Default is None.\n\n    Returns:\n        Album object for newly created album\n\n    Raises:\n        AppleScriptError if error creating the album\n    \"\"\"\n    if folder is None:\n        album_id = run_script(\"photosLibraryCreateAlbum\", name)\n    else:\n        album_id = run_script(\n            \"photosLibraryCreateAlbumAtFolder\", name, folder.idstring\n        )\n\n    if album_id != kMissingValue:\n        return Album(album_id)\n    else:\n        raise AppleScriptError(f\"Could not create album {name}\")\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.create_folder","title":"<code>create_folder(name, folder=None)</code>","text":"<p>creates a folder</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of new folder</p> required <code>folder</code> <code>'Folder'</code> <p>Folder object in which to create the new folder.     If None, creates top-level folder. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Folder'</code> <p>Folder object for newly created folder</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def create_folder(self, name: str, folder: \"Folder\" = None) -&gt; \"Folder\":\n    \"\"\"creates a folder\n\n    Args:\n        name: name of new folder\n        folder: Folder object in which to create the new folder.\n                If None, creates top-level folder. Default is None.\n\n    Returns:\n        Folder object for newly created folder\n\n    Raises:\n        AppleScriptError if folder cannot be created\n    \"\"\"\n    if folder is None:\n        folder_id = run_script(\"photosLibraryCreateFolder\", name)\n    else:\n        folder_id = run_script(\n            \"photosLibraryCreateFolderAtFolder\", name, folder.idstring\n        )\n\n    if folder_id != kMissingValue:\n        return Folder(idstring=folder_id)\n    else:\n        raise AppleScriptError(f\"Could not create folder {name}\")\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.delete_album","title":"<code>delete_album(album)</code>","text":"<p>deletes album (but does not delete photos in the album)</p> <p>Parameters:</p> Name Type Description Default <code>album</code> <code>'Album'</code> <p>an Album object for album to delete</p> required Source code in <code>photoscript/__init__.py</code> <pre><code>def delete_album(self, album: \"Album\"):\n    \"\"\"deletes album (but does not delete photos in the album)\n\n    Args:\n        album: an Album object for album to delete\n    \"\"\"\n    return run_script(\"photosLibraryDeleteAlbum\", album.id)\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.delete_folder","title":"<code>delete_folder(folder)</code>","text":"<p>Deletes folder (and all its sub-folders and albums)</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>'Folder'</code> <p>a Folder object for folder to delete</p> required Notes <p>On macOS 10.15 &amp; above, only top-level folders can be deleted. Sub-folders cannot be deleted due to a bug in Photos' AppleScript implementation.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def delete_folder(self, folder: \"Folder\"):\n    \"\"\"Deletes folder (and all its sub-folders and albums)\n\n    Args:\n        folder: a Folder object for folder to delete\n\n    Notes:\n        On macOS 10.15 &amp; above, only top-level folders can be deleted.\n        Sub-folders cannot be deleted due to a bug in Photos' AppleScript\n        implementation.\n    \"\"\"\n    return run_script(\"photosLibraryDeleteFolder\", folder.idstring)\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.folder","title":"<code>folder(name=None, path=None, uuid=None, top_level=True)</code>","text":"<p>Folder instance by name or uuid</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of folder, e.g. \"My Folder\"</p> <code>None</code> <code>path</code> <code>list[str]</code> <p>path of folder as list of strings, e.g. [\"My Folder\", \"Subfolder\"]</p> <code>None</code> <code>uuid</code> <code>str</code> <p>id of folder, e.g. \"F1234567-1234-1234-1234-1234567890AB\"</p> <code>None</code> <code>top_level</code> <p>if True, only searches top level folders by name; default is True</p> <code>True</code> <p>Returns:</p> Type Description <p>Folder object or None if folder could not be found</p> Notes <p>Must pass one of path, name, or uuid but not more than one If more than one folder with same name, returns first one found.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def folder(\n    self, name: str = None, path: list[str] = None, uuid: str = None, top_level=True\n):\n    \"\"\"Folder instance by name or uuid\n\n    Args:\n        name: name of folder, e.g. \"My Folder\"\n        path: path of folder as list of strings, e.g. [\"My Folder\", \"Subfolder\"]\n        uuid: id of folder, e.g. \"F1234567-1234-1234-1234-1234567890AB\"\n        top_level: if True, only searches top level folders by name; default is True\n\n    Returns:\n        Folder object or None if folder could not be found\n\n    Raises:\n        ValueError not one of name, path, or uuid is passed\n\n    Notes:\n        Must pass one of path, name, or uuid but not more than one\n        If more than one folder with same name, returns first one found.\n    \"\"\"\n    if sum(bool(x) for x in [name, path, uuid]) != 1:\n        raise ValueError(\n            \"Must pass one of name, path, or uuid but not more than one\"\n        )\n\n    if path:\n        idstring = run_script(\"folderGetIDStringFromPath\", path)\n        return Folder(idstring=idstring) if idstring != kMissingValue else None\n\n    if name:\n        idstring = run_script(\n            \"photosLibraryGetFolderIDStringForName\", name, top_level\n        )\n        return Folder(idstring=idstring) if idstring != kMissingValue else None\n\n    if uuid:\n        idstring = run_script(\n            \"photosLibraryGetFolderIDStringForID\", uuid, top_level\n        )\n        return Folder(idstring=idstring) if idstring != kMissingValue else None\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.folder_by_path","title":"<code>folder_by_path(folder_path)</code>","text":"<p>Return folder in the library by path</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <p>list of folder names in descending path order, e.g. [\"Folder\", \"SubFolder1\", \"SubFolder2\"]</p> required <p>Returns:</p> Type Description <p>Folder object for folder at folder_path or None if not found</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def folder_by_path(self, folder_path):\n    \"\"\"Return folder in the library by path\n\n    Args:\n        folder_path: list of folder names in descending path order, e.g. [\"Folder\", \"SubFolder1\", \"SubFolder2\"]\n\n    Returns:\n        Folder object for folder at folder_path or None if not found\n    \"\"\"\n    folder_id = run_script(\"folderIDByPath\", folder_path)\n    return Folder(folder_id) if folder_id != kMissingValue else None\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.folder_names","title":"<code>folder_names(top_level=False)</code>","text":"<p>List of folder names in the Photos library</p> <p>Parameters:</p> Name Type Description Default <code>top_level</code> <p>if True, returns only top-level folders otherwise also returns sub-folders; default is False</p> <code>False</code> Source code in <code>photoscript/__init__.py</code> <pre><code>def folder_names(self, top_level=False):\n    \"\"\"List of folder names in the Photos library\n\n    Args:\n        top_level: if True, returns only top-level folders otherwise also returns sub-folders; default is False\n    \"\"\"\n    return run_script(\"photosLibraryFolderNames\", top_level)\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.folders","title":"<code>folders(top_level=True)</code>","text":"<p>list of Folder objects for all folders</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def folders(self, top_level=True):\n    \"\"\"list of Folder objects for all folders\"\"\"\n    folder_ids = run_script(\"photosLibraryFolderIDs\", top_level)\n    return [Folder(uuid) for uuid in folder_ids]\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.hide","title":"<code>hide()</code>","text":"<p>Tell Photos to hide its window</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def hide(self):\n    \"\"\"Tell Photos to hide its window\"\"\"\n    run_script(\"photosLibraryHide\")\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.import_photos","title":"<code>import_photos(photo_paths, album=None, skip_duplicate_check=False)</code>","text":"<p>import photos</p> <p>Parameters:</p> Name Type Description Default <code>photo_paths</code> <p>list of file paths to import as str or pathlib.Path</p> required <code>album</code> <p>optional, Album object for album to import into</p> <code>None</code> <code>skip_duplicate_check</code> <p>if True, Photos will not check for duplicates on import, default is False.</p> <code>False</code> <p>Returns:</p> Type Description <p>list of Photo objects for imported photos</p> If you attempt to import a duplicate photo and skip_duplicate_check != True, <p>Photos will block with drop-down sheet until the user clicks \"Cancel, Import, or Don't Import.\"</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def import_photos(self, photo_paths, album=None, skip_duplicate_check=False):\n    \"\"\"import photos\n\n    Args:\n        photo_paths: list of file paths to import as str or pathlib.Path\n        album: optional, Album object for album to import into\n        skip_duplicate_check: if True, Photos will not check for duplicates on import, default is False.\n\n    Returns:\n        list of Photo objects for imported photos\n\n    NOTE: If you attempt to import a duplicate photo and skip_duplicate_check != True,\n        Photos will block with drop-down sheet until the user clicks \"Cancel, Import, or Don't Import.\"\n    \"\"\"\n    # stringify paths in case pathlib.Path paths are passed\n    photo_paths = [str(photo_path) for photo_path in photo_paths]\n    if album is not None:\n        photo_ids = run_script(\n            \"photosLibraryImportToAlbum\",\n            photo_paths,\n            album.id,\n            skip_duplicate_check,\n        )\n    else:\n        photo_ids = run_script(\n            \"photosLibraryImport\", photo_paths, skip_duplicate_check\n        )\n\n    return [Photo(photo) for photo in photo_ids]\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.make_album_folders","title":"<code>make_album_folders(album_name, folder_path)</code>","text":"<p>Make album in a folder path.  If either the album or any component of the    folder path doesn't exist, it will be created.  If album or folder path    does exist, no duplicate is created.  Folder path is created recursively    if needed.</p> <p>Parameters:</p> Name Type Description Default <code>album_name</code> <p>name of album to create.  If album already exists, returns existing album.</p> required <code>folder_path</code> <p>list of folder names in descending path order, e.g. [\"Folder\", \"SubFolder1\", \"SubFolder2\"].</p> required <p>Returns:</p> Type Description <p>Album object.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def make_album_folders(self, album_name, folder_path):\n    \"\"\"Make album in a folder path.  If either the album or any component of the\n       folder path doesn't exist, it will be created.  If album or folder path\n       does exist, no duplicate is created.  Folder path is created recursively\n       if needed.\n\n    Args:\n        album_name: name of album to create.  If album already exists, returns existing album.\n        folder_path: list of folder names in descending path order, e.g. [\"Folder\", \"SubFolder1\", \"SubFolder2\"].\n\n    Returns:\n        Album object.\n\n    Raises:\n        ValueError if folder_path is empty or album_name is None.\n        TypeError if folder_path is not a list.\n    \"\"\"\n    if album_name is None or not len(album_name):\n        raise ValueError(\"album_name must not be None\")\n    if not isinstance(folder_path, list):\n        raise TypeError(\"list expected for folder_path\")\n    if not folder_path:\n        raise ValueError(\"no values in folder_path\")\n\n    folder = self.make_folders(folder_path)\n    album = folder.album(album_name)\n    if album is None:\n        album = folder.create_album(album_name)\n    return album\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.make_folders","title":"<code>make_folders(folder_path)</code>","text":"<p>Recursively makes folders and subfolders.  Works similar to os.makedirs_. If any component of folder_path already exists, does not raise error.</p> <p>.. _os.makedirs: https://docs.python.org/3/library/os.html#os.makedirs</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <p>list of folder names in descending path order, e.g. [\"Folder\", \"SubFolder1\", \"SubFolder2\"]</p> required <p>Returns:</p> Type Description <p>Folder object for the final sub folder</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def make_folders(self, folder_path):\n    \"\"\"Recursively makes folders and subfolders.  Works similar to os.makedirs_.\n    If any component of folder_path already exists, does not raise error.\n\n    .. _os.makedirs: https://docs.python.org/3/library/os.html#os.makedirs\n\n    Args:\n        folder_path: list of folder names in descending path order, e.g. [\"Folder\", \"SubFolder1\", \"SubFolder2\"]\n\n    Returns:\n        Folder object for the final sub folder\n\n    Raises:\n        ValueError if folder_path is empty\n        TypeError if folder_path is not a list\n    \"\"\"\n    if not isinstance(folder_path, list):\n        raise TypeError(\"list expected for folder_path\")\n    if not folder_path:\n        raise ValueError(\"no values in folder_path\")\n\n    folder = self.folder(folder_path[0], top_level=True)\n    if folder is None:\n        folder = self.create_folder(folder_path[0])\n    for subfolder_name in folder_path[1:]:\n        subfolder = folder.folder(subfolder_name)\n        if subfolder is None:\n            subfolder = folder.create_folder(subfolder_name)\n        folder = subfolder\n    return folder\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.open","title":"<code>open(library_path, delay=10)</code>","text":"<p>open a library and wait for delay for user to acknowledge in Photos</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def open(self, library_path, delay=10):\n    \"\"\"open a library and wait for delay for user to acknowledge in Photos\"\"\"\n    # Note: Unlike the other AppleScript scripts, this one is not included in photoscript.applescript\n    # because, for reasons I cannot explain, it fails to run if included there\n    if not pathlib.Path(library_path).is_dir():\n        raise ValueError(f\"{library_path} does not appear to be a Photos library\")\n    self.activate()\n    script = AppleScript(\n        f\"\"\"\n        set tries to 0\n        repeat while tries &lt; 5\n            try\n                tell application \"Photos\"\n                    activate\n                    delay 3 \n                    open POSIX file \"{library_path}\"\n                    delay {delay}\n                end tell\n                set tries to 5\n            on error\n                set tries to tries + 1\n            end try\n        end repeat\n    \"\"\"\n    )\n    script.run()\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.photos","title":"<code>photos(search=None, uuid=None, range_=None)</code>","text":"<p>Returns a generator that yields Photo objects for media items in the library.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <p>optional text string to search for (returns matching items)</p> <code>None</code> <code>uuid</code> <p>optional list of UUIDs to get</p> <code>None</code> <code>range</code> <p>optional list of [start, stop] sequence of photos to get</p> required <p>Returns:</p> Type Description <p>Generator that yields Photo objects</p> <p>Note: photos() returns a generator instead of a list because retrieving all the photos from a large Photos library can take a very long time--on my system, the rate is about 1 per second; this is limited by the Photos AppleScript interface and I've not found anyway to speed it up.  Using a generator allows you process photos individually rather than waiting, possibly hours, for Photos to return the results.</p> <p>range works like python's range function.  Thus range=[0,4] will return Photos 0, 1, 2, 3; range=[10] returns the first 10 photos in the library; range start must be in range 0 to len(PhotosLibrary())-1, stop in range 1 to len(PhotosLibrary()).  You may be able to optimize the speed by which photos are return by chunking up requests in batches of photos using range, e.g. request 10 photos at a time.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def photos(self, search=None, uuid=None, range_=None):\n    \"\"\"Returns a generator that yields Photo objects for media items in the library.\n\n    Args:\n        search: optional text string to search for (returns matching items)\n        uuid: optional list of UUIDs to get\n        range: optional list of [start, stop] sequence of photos to get\n\n    Returns:\n        Generator that yields Photo objects\n\n    Raises:\n        ValueError if more than one of search, uuid, range passed or invalid range\n        TypeError if list not passed for range\n\n    Note: photos() returns a generator instead of a list because retrieving all the photos\n    from a large Photos library can take a very long time--on my system, the rate is about 1\n    per second; this is limited by the Photos AppleScript interface and I've not found\n    anyway to speed it up.  Using a generator allows you process photos individually rather\n    than waiting, possibly hours, for Photos to return the results.\n\n    range works like python's range function.  Thus range=[0,4] will return\n    Photos 0, 1, 2, 3; range=[10] returns the first 10 photos in the library;\n    range start must be in range 0 to len(PhotosLibrary())-1,\n    stop in range 1 to len(PhotosLibrary()).  You may be able to optimize the speed by which\n    photos are return by chunking up requests in batches of photos using range,\n    e.g. request 10 photos at a time.\n    \"\"\"\n    if len([x for x in [search, uuid, range_] if x]) &gt; 1:\n        raise ValueError(\"Cannot pass more than one of search, uuid, range_\")\n\n    if not any([search, uuid, range_]):\n        return self._iterphotos()\n\n    if search is not None:\n        # search for text\n        photo_ids = run_script(\"photosLibrarySearchPhotos\", search)\n    elif uuid:\n        # search by uuid\n        photo_ids = uuid\n    else:\n        # search by range\n        if not isinstance(range_, list):\n            raise TypeError(\"range_ must be a list\")\n\n        if not (1 &lt;= len(range_) &lt;= 2):\n            raise ValueError(\"invalid range, must be list of len 1 or 2\")\n\n        if len(range_) == 1:\n            start = 0\n            stop = range_[0]\n        else:\n            start, stop = range_\n\n        if start &gt; stop:\n            raise ValueError(\"start range must be &lt;= stop range\")\n\n        count = len(self)\n        if not ((0 &lt;= start &lt;= count - 1) and (1 &lt;= stop &lt;= count)):\n            raise ValueError(\n                f\"invalid range: valid range is start: 0 to {count-1}, stop: 1 to {count}\"\n            )\n\n        photo_ids = run_script(\"photosLibraryGetPhotoByRange\", start + 1, stop)\n\n    return self._iterphotos(uuids=photo_ids) if photo_ids else []\n</code></pre>"},{"location":"reference/#photoscript.PhotosLibrary.quit","title":"<code>quit()</code>","text":"<p>quit Photos.app</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def quit(self):\n    \"\"\"quit Photos.app\"\"\"\n    run_script(\"photosLibraryQuit\")\n</code></pre>"},{"location":"reference/#photo","title":"Photo","text":"Source code in <code>photoscript/__init__.py</code> <pre><code>class Photo:\n    def __init__(self, uuid):\n        # check to see if we need to add UUID suffix\n        uuid, id_ = uuid_to_id(uuid, UUID_SUFFIX_PHOTO)\n        if valid := run_script(\"photoExists\", uuid):\n            self.id = id_\n            self._uuid = uuid\n        else:\n            raise ValueError(f\"Invalid photo id: {uuid}\")\n\n    @property\n    def uuid(self):\n        \"\"\"UUID of Photo\"\"\"\n        return self._uuid\n\n    @property\n    def name(self):\n        \"\"\"name of photo (read/write)\"\"\"\n        name = run_script(\"photoName\", self.id)\n        return name if name not in [kMissingValue, \"\"] else \"\"\n\n    @name.setter\n    def name(self, name):\n        \"\"\"set name of photo\"\"\"\n        name = \"\" if name is None else name\n        return run_script(\"photoSetName\", self.id, name)\n\n    @property\n    def title(self):\n        \"\"\"title of photo (alias for name)\"\"\"\n        return self.name\n\n    @title.setter\n    def title(self, title):\n        \"\"\"set title of photo (alias for name)\"\"\"\n        name = \"\" if title is None else title\n        return run_script(\"photoSetName\", self.id, name)\n\n    @property\n    def description(self):\n        \"\"\"description of photo\"\"\"\n        descr = run_script(\"photoDescription\", self.id)\n        return descr if descr != kMissingValue else \"\"\n\n    @description.setter\n    def description(self, descr):\n        \"\"\"set description of photo\"\"\"\n        descr = \"\" if descr is None else descr\n        return run_script(\"photoSetDescription\", self.id, descr)\n\n    @property\n    def keywords(self):\n        \"\"\"list of keywords for photo\"\"\"\n        keywords = run_script(\"photoKeywords\", self.id)\n        if not isinstance(keywords, list):\n            keywords = [keywords] if keywords != kMissingValue else []\n        return keywords\n\n    @keywords.setter\n    def keywords(self, keywords):\n        \"\"\"set keywords to list\"\"\"\n        keywords = [] if keywords is None else keywords\n        return run_script(\"photoSetKeywords\", self.id, keywords)\n\n    @property\n    def favorite(self):\n        \"\"\"return favorite status (boolean)\"\"\"\n        return run_script(\"photoFavorite\", self.id)\n\n    @favorite.setter\n    def favorite(self, favorite):\n        \"\"\"set favorite status (boolean)\"\"\"\n        favorite = bool(favorite)\n        return run_script(\"photoSetFavorite\", self.id, favorite)\n\n    @property\n    def height(self):\n        \"\"\"height of photo in pixels\"\"\"\n        return run_script(\"photoHeight\", self.id)\n\n    @property\n    def width(self):\n        \"\"\"width of photo in pixels\"\"\"\n        return run_script(\"photoWidth\", self.id)\n\n    @property\n    def altitude(self):\n        \"\"\"GPS altitude of photo in meters\"\"\"\n        altitude = run_script(\"photoAltitude\", self.id)\n        return altitude if altitude != kMissingValue else None\n\n    @property\n    def location(self):\n        \"\"\"The GPS latitude and longitude, in a tuple of 2 numbers or None.\n        Latitude in range -90.0 to 90.0, longitude in range -180.0 to 180.0.\n        \"\"\"\n        location = run_script(\"photoLocation\", self.id)\n        location[0] = None if location[0] == kMissingValue else location[0]\n        location[1] = None if location[1] == kMissingValue else location[1]\n        return tuple(location)\n\n    @location.setter\n    def location(self, location):\n        \"\"\"Set GPS latitude and longitude, in a tuple of 2 numbers or None.\n        Latitude in range -90.0 to 90.0, longitude in range -180.0 to 180.0.\n        \"\"\"\n\n        if not isinstance(location, tuple) and location is not None:\n            raise ValueError(\"location must be a tuple of (latitude, longitude)\")\n\n        location = (None, None) if location is None else location\n\n        if location[0] is not None and not -90.0 &lt;= location[0] &lt;= 90.0:\n            raise ValueError(\"latitude must be in range -90.0 to 90.0\")\n\n        if location[1] is not None and not -180.0 &lt;= location[1] &lt;= 180.0:\n            raise ValueError(\"longitude must be in range -180.0 to 180.0\")\n\n        location = (\n            kMissingValue if location[0] is None else location[0],\n            kMissingValue if location[1] is None else location[1],\n        )\n\n        return run_script(\"photoSetLocation\", self.id, location)\n\n    @property\n    def date(self):\n        \"\"\"date of photo as timezone-naive datetime.datetime object\"\"\"\n        return run_script(\"photoDate\", self.id)\n\n    @date.setter\n    def date(self, date):\n        \"\"\"Set date of photo as timezone-naive datetime.datetime object\n\n        Args:\n            date: timezone-naive datetime.datetime object\n        \"\"\"\n        return run_script(\"photoSetDate\", self.id, date)\n\n    @property\n    def filename(self):\n        \"\"\"filename of photo\"\"\"\n        return run_script(\"photoFilename\", self.id)\n\n    @property\n    def albums(self):\n        \"\"\"list of Album objects for albums photo is contained in\"\"\"\n        albums = run_script(\"photoAlbums\", self.id)\n        return [Album(album) for album in albums]\n\n    def export(\n        self,\n        export_path,\n        original=False,\n        overwrite=False,\n        timeout=120,\n        reveal_in_finder=False,\n    ):\n        \"\"\"Export photo\n\n        Args:\n            photo: Photo object to export\n            export_path: path to export to\n            original: if True, export original image, otherwise export current image; default = False\n            overwrite: if True, export will overwrite a file of same name as photo in export_path; default = False\n            timeout: number of seconds to wait for Photos to complete export before timing out; default = 120\n            reveal_in_finder: if True, will open Finder with exported items selected when done; default = False\n\n        Returns:\n            List of full paths of exported photos.  There may be more than one photo exported due\n            to live images and burst images.\n\n        Raises:\n            ValueError if export_path is not a valid directory\n\n        Note: Photos always exports as high-quality JPEG unless original=True.\n        If original=True, will export all burst images for burst photos and\n        live movie for live photos.  If original=False, only the primary image from a\n        burst set will be exported for burst photos and the live movie component of a\n        live image will not be exported, only the JPEG component.\n        \"\"\"\n        return PhotosLibrary()._export_photo(\n            self,\n            export_path=export_path,\n            original=original,\n            overwrite=overwrite,\n            timeout=timeout,\n            reveal_in_finder=reveal_in_finder,\n        )\n\n    def duplicate(self):\n        \"\"\"duplicates the photo and returns Photo object for the duplicate\"\"\"\n        dup_id = run_script(\"photoDuplicate\", self.id)\n        return Photo(dup_id)\n\n    def spotlight(self):\n        \"\"\"spotlight the photo in Photos\"\"\"\n        run_script(\"photoSpotlight\", self.id)\n</code></pre>"},{"location":"reference/#photoscript.Photo.albums","title":"<code>albums</code>  <code>property</code>","text":"<p>list of Album objects for albums photo is contained in</p>"},{"location":"reference/#photoscript.Photo.altitude","title":"<code>altitude</code>  <code>property</code>","text":"<p>GPS altitude of photo in meters</p>"},{"location":"reference/#photoscript.Photo.date","title":"<code>date</code>  <code>property</code> <code>writable</code>","text":"<p>date of photo as timezone-naive datetime.datetime object</p>"},{"location":"reference/#photoscript.Photo.description","title":"<code>description</code>  <code>property</code> <code>writable</code>","text":"<p>description of photo</p>"},{"location":"reference/#photoscript.Photo.favorite","title":"<code>favorite</code>  <code>property</code> <code>writable</code>","text":"<p>return favorite status (boolean)</p>"},{"location":"reference/#photoscript.Photo.filename","title":"<code>filename</code>  <code>property</code>","text":"<p>filename of photo</p>"},{"location":"reference/#photoscript.Photo.height","title":"<code>height</code>  <code>property</code>","text":"<p>height of photo in pixels</p>"},{"location":"reference/#photoscript.Photo.keywords","title":"<code>keywords</code>  <code>property</code> <code>writable</code>","text":"<p>list of keywords for photo</p>"},{"location":"reference/#photoscript.Photo.location","title":"<code>location</code>  <code>property</code> <code>writable</code>","text":"<p>The GPS latitude and longitude, in a tuple of 2 numbers or None. Latitude in range -90.0 to 90.0, longitude in range -180.0 to 180.0.</p>"},{"location":"reference/#photoscript.Photo.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>name of photo (read/write)</p>"},{"location":"reference/#photoscript.Photo.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>title of photo (alias for name)</p>"},{"location":"reference/#photoscript.Photo.uuid","title":"<code>uuid</code>  <code>property</code>","text":"<p>UUID of Photo</p>"},{"location":"reference/#photoscript.Photo.width","title":"<code>width</code>  <code>property</code>","text":"<p>width of photo in pixels</p>"},{"location":"reference/#photoscript.Photo.duplicate","title":"<code>duplicate()</code>","text":"<p>duplicates the photo and returns Photo object for the duplicate</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def duplicate(self):\n    \"\"\"duplicates the photo and returns Photo object for the duplicate\"\"\"\n    dup_id = run_script(\"photoDuplicate\", self.id)\n    return Photo(dup_id)\n</code></pre>"},{"location":"reference/#photoscript.Photo.export","title":"<code>export(export_path, original=False, overwrite=False, timeout=120, reveal_in_finder=False)</code>","text":"<p>Export photo</p> <p>Parameters:</p> Name Type Description Default <code>photo</code> <p>Photo object to export</p> required <code>export_path</code> <p>path to export to</p> required <code>original</code> <p>if True, export original image, otherwise export current image; default = False</p> <code>False</code> <code>overwrite</code> <p>if True, export will overwrite a file of same name as photo in export_path; default = False</p> <code>False</code> <code>timeout</code> <p>number of seconds to wait for Photos to complete export before timing out; default = 120</p> <code>120</code> <code>reveal_in_finder</code> <p>if True, will open Finder with exported items selected when done; default = False</p> <code>False</code> <p>Returns:</p> Type Description <p>List of full paths of exported photos.  There may be more than one photo exported due</p> <p>to live images and burst images.</p> <p>Note: Photos always exports as high-quality JPEG unless original=True. If original=True, will export all burst images for burst photos and live movie for live photos.  If original=False, only the primary image from a burst set will be exported for burst photos and the live movie component of a live image will not be exported, only the JPEG component.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def export(\n    self,\n    export_path,\n    original=False,\n    overwrite=False,\n    timeout=120,\n    reveal_in_finder=False,\n):\n    \"\"\"Export photo\n\n    Args:\n        photo: Photo object to export\n        export_path: path to export to\n        original: if True, export original image, otherwise export current image; default = False\n        overwrite: if True, export will overwrite a file of same name as photo in export_path; default = False\n        timeout: number of seconds to wait for Photos to complete export before timing out; default = 120\n        reveal_in_finder: if True, will open Finder with exported items selected when done; default = False\n\n    Returns:\n        List of full paths of exported photos.  There may be more than one photo exported due\n        to live images and burst images.\n\n    Raises:\n        ValueError if export_path is not a valid directory\n\n    Note: Photos always exports as high-quality JPEG unless original=True.\n    If original=True, will export all burst images for burst photos and\n    live movie for live photos.  If original=False, only the primary image from a\n    burst set will be exported for burst photos and the live movie component of a\n    live image will not be exported, only the JPEG component.\n    \"\"\"\n    return PhotosLibrary()._export_photo(\n        self,\n        export_path=export_path,\n        original=original,\n        overwrite=overwrite,\n        timeout=timeout,\n        reveal_in_finder=reveal_in_finder,\n    )\n</code></pre>"},{"location":"reference/#photoscript.Photo.spotlight","title":"<code>spotlight()</code>","text":"<p>spotlight the photo in Photos</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def spotlight(self):\n    \"\"\"spotlight the photo in Photos\"\"\"\n    run_script(\"photoSpotlight\", self.id)\n</code></pre>"},{"location":"reference/#album","title":"Album","text":"Source code in <code>photoscript/__init__.py</code> <pre><code>class Album:\n    def __init__(self, uuid):\n        # check to see if we need to add UUID suffix\n        uuid, id_ = uuid_to_id(uuid, UUID_SUFFIX_ALBUM)\n        if valuuidalbum := run_script(\"albumExists\", id_):\n            self.id = id_\n            self._uuid = uuid\n        else:\n            raise ValueError(f\"Invalid album id: {uuid}\")\n\n    @property\n    def uuid(self):\n        \"\"\"UUID of Album (read only)\"\"\"\n        return self._uuid\n\n    @property\n    def name(self):\n        \"\"\"name of album (read/write)\"\"\"\n        name = run_script(\"albumName\", self.id)\n        return name if name != kMissingValue else \"\"\n\n    @name.setter\n    def name(self, name):\n        \"\"\"set name of album\"\"\"\n        name = \"\" if name is None else name\n        return run_script(\"albumSetName\", self.id, name)\n\n    @property\n    def title(self):\n        \"\"\"title of album (alias for Album.name)\"\"\"\n        return self.name\n\n    @title.setter\n    def title(self, title):\n        \"\"\"set title of album (alias for name)\"\"\"\n        name = \"\" if title is None else title\n        return run_script(\"albumSetName\", self.id, name)\n\n    @property\n    def parent_id(self):\n        \"\"\"parent container id\"\"\"\n        return run_script(\"albumParent\", self.id)\n\n    # TODO: if no parent should return a \"My Albums\" object that contains all top-level folders/albums\n    @property\n    def parent(self):\n        \"\"\"Return parent Folder object\"\"\"\n        parent_id = self.parent_id\n        if parent_id != 0:\n            return Folder(parent_id)\n        else:\n            return None\n\n    def path_str(self, delim=\"/\"):\n        \"\"\"Return internal library path to album as string.\n            e.g. \"Folder/SubFolder/AlbumName\"\n\n        Args:\n            delim: character to use as delimiter between path elements; default is \"/\"\n\n        Raises:\n            ValueError if delim is not a single character\n        \"\"\"\n        if len(delim) &gt; 1:\n            raise ValueError(\"delim must be single character\")\n\n        return run_script(\"albumGetPath\", self.id, delim)\n\n    def photos(self):\n        \"\"\"list of Photo objects for photos contained in album\"\"\"\n        photo_ids = run_script(\"albumPhotes\", self.id)\n        return [Photo(uuid) for uuid in photo_ids]\n\n    def add(self, photos):\n        \"\"\"add photos from the library to album\n\n        Args:\n            photos: list of Photo objects to add to album\n\n        Returns:\n            list of Photo objects for added photos\n        \"\"\"\n        uuids = [p.id for p in photos]\n        added_ids = run_script(\"albumAdd\", self.id, uuids)\n        return [Photo(uuid) for uuid in added_ids]\n\n    def import_photos(self, photo_paths, skip_duplicate_check=False):\n        \"\"\"import photos\n\n        Args:\n            photos: list of file paths to import\n            skip_duplicate_check: if True, Photos will not check for duplicates on import, default is False\n\n        Returns:\n            list of Photo objects for imported photos\n        \"\"\"\n        library = PhotosLibrary()\n        return library.import_photos(\n            photo_paths, album=self, skip_duplicate_check=skip_duplicate_check\n        )\n\n    def export(\n        self,\n        export_path,\n        original=False,\n        overwrite=False,\n        timeout=120,\n        reveal_in_finder=False,\n    ):\n        \"\"\"Export photos in album to path\n\n        Args:\n            photo: Photo object to export\n            export_path: path to export to\n            original: if True, export original image, otherwise export current image; default = False\n            overwrite: if True, export will overwrite a file of same name as photo in export_path; default = False\n            timeout: number of seconds to wait for Photos to complete export (for each photo) before timing out; default = 120\n            reveal_in_finder: if True, will open Finder with exported items selected when done; default = False\n\n        Returns:\n            List of full paths of exported photos.  There may be more than one photo exported due\n            to live images and burst images.\n\n        Raises:\n            ValueError if export_path is not a valid directory\n\n        Note: Photos always exports as high-quality JPEG unless original=True.\n        If original=True, will export all burst images for burst photos and\n        live movie for live photos.  If original=False, only the primary image from a\n        burst set will be exported for burst photos and the live movie component of a\n        live image will not be exported, only the JPEG component.\n        \"\"\"\n        exported_photos = []\n        for photo in self.photos():\n            exported_photos.extend(\n                photo.export(\n                    export_path=export_path,\n                    original=original,\n                    overwrite=overwrite,\n                    timeout=timeout,\n                )\n            )\n        if reveal_in_finder and exported_photos:\n            run_script(\"revealInFinder\", exported_photos)\n        return exported_photos\n\n    def remove_by_id(self, photo_ids):\n        \"\"\"Remove photos from album.\n            Note: Photos does not provide a way to remove photos from an album via AppleScript.\n            This method actually creates a new Album with the same name as the original album and\n            copies all photos from original album with exception of those to remove to the new album\n            then deletes the old album.\n\n        Args:\n            photo_ids: list of photo ids to remove\n\n        Returns:\n            new Album object for the new album with photos removed.\n        \"\"\"\n        photoslib = PhotosLibrary()\n        new_album = photoslib.create_album(\n            photoslib._temp_album_name(), folder=self.parent\n        )\n        old_photos = self.photos()\n        new_photo_uuids = [\n            photo.id for photo in old_photos if photo.id not in photo_ids\n        ]\n        new_photos = [Photo(uuid) for uuid in new_photo_uuids]\n        if new_photos:\n            new_album.add(new_photos)\n        name = self.name\n        photoslib.delete_album(self)\n        new_album.name = name\n        self.id = new_album.id\n        self._uuid = new_album.uuid\n        return new_album\n\n    def remove(self, photos):\n        \"\"\"Remove photos from album.\n            Note: Photos does not provide a way to remove photos from an album via AppleScript.\n            This method actually creates a new Album with the same name as the original album and\n            copies all photos from original album with exception of those to remove to the new album\n            then deletes the old album.\n\n        Args:\n            photos: list of Photo objects to remove\n\n        Returns:\n            new Album object for the new album with photos removed.\n        \"\"\"\n        photo_uuids = [photo.id for photo in photos]\n        return self.remove_by_id(photo_uuids)\n\n    def spotlight(self):\n        \"\"\"spotlight the album in Photos\"\"\"\n        run_script(\"albumSpotlight\", self.id)\n\n    def __len__(self):\n        return run_script(\"albumCount\", self.id)\n</code></pre>"},{"location":"reference/#photoscript.Album.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>name of album (read/write)</p>"},{"location":"reference/#photoscript.Album.parent","title":"<code>parent</code>  <code>property</code>","text":"<p>Return parent Folder object</p>"},{"location":"reference/#photoscript.Album.parent_id","title":"<code>parent_id</code>  <code>property</code>","text":"<p>parent container id</p>"},{"location":"reference/#photoscript.Album.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>title of album (alias for Album.name)</p>"},{"location":"reference/#photoscript.Album.uuid","title":"<code>uuid</code>  <code>property</code>","text":"<p>UUID of Album (read only)</p>"},{"location":"reference/#photoscript.Album.add","title":"<code>add(photos)</code>","text":"<p>add photos from the library to album</p> <p>Parameters:</p> Name Type Description Default <code>photos</code> <p>list of Photo objects to add to album</p> required <p>Returns:</p> Type Description <p>list of Photo objects for added photos</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def add(self, photos):\n    \"\"\"add photos from the library to album\n\n    Args:\n        photos: list of Photo objects to add to album\n\n    Returns:\n        list of Photo objects for added photos\n    \"\"\"\n    uuids = [p.id for p in photos]\n    added_ids = run_script(\"albumAdd\", self.id, uuids)\n    return [Photo(uuid) for uuid in added_ids]\n</code></pre>"},{"location":"reference/#photoscript.Album.export","title":"<code>export(export_path, original=False, overwrite=False, timeout=120, reveal_in_finder=False)</code>","text":"<p>Export photos in album to path</p> <p>Parameters:</p> Name Type Description Default <code>photo</code> <p>Photo object to export</p> required <code>export_path</code> <p>path to export to</p> required <code>original</code> <p>if True, export original image, otherwise export current image; default = False</p> <code>False</code> <code>overwrite</code> <p>if True, export will overwrite a file of same name as photo in export_path; default = False</p> <code>False</code> <code>timeout</code> <p>number of seconds to wait for Photos to complete export (for each photo) before timing out; default = 120</p> <code>120</code> <code>reveal_in_finder</code> <p>if True, will open Finder with exported items selected when done; default = False</p> <code>False</code> <p>Returns:</p> Type Description <p>List of full paths of exported photos.  There may be more than one photo exported due</p> <p>to live images and burst images.</p> <p>Note: Photos always exports as high-quality JPEG unless original=True. If original=True, will export all burst images for burst photos and live movie for live photos.  If original=False, only the primary image from a burst set will be exported for burst photos and the live movie component of a live image will not be exported, only the JPEG component.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def export(\n    self,\n    export_path,\n    original=False,\n    overwrite=False,\n    timeout=120,\n    reveal_in_finder=False,\n):\n    \"\"\"Export photos in album to path\n\n    Args:\n        photo: Photo object to export\n        export_path: path to export to\n        original: if True, export original image, otherwise export current image; default = False\n        overwrite: if True, export will overwrite a file of same name as photo in export_path; default = False\n        timeout: number of seconds to wait for Photos to complete export (for each photo) before timing out; default = 120\n        reveal_in_finder: if True, will open Finder with exported items selected when done; default = False\n\n    Returns:\n        List of full paths of exported photos.  There may be more than one photo exported due\n        to live images and burst images.\n\n    Raises:\n        ValueError if export_path is not a valid directory\n\n    Note: Photos always exports as high-quality JPEG unless original=True.\n    If original=True, will export all burst images for burst photos and\n    live movie for live photos.  If original=False, only the primary image from a\n    burst set will be exported for burst photos and the live movie component of a\n    live image will not be exported, only the JPEG component.\n    \"\"\"\n    exported_photos = []\n    for photo in self.photos():\n        exported_photos.extend(\n            photo.export(\n                export_path=export_path,\n                original=original,\n                overwrite=overwrite,\n                timeout=timeout,\n            )\n        )\n    if reveal_in_finder and exported_photos:\n        run_script(\"revealInFinder\", exported_photos)\n    return exported_photos\n</code></pre>"},{"location":"reference/#photoscript.Album.import_photos","title":"<code>import_photos(photo_paths, skip_duplicate_check=False)</code>","text":"<p>import photos</p> <p>Parameters:</p> Name Type Description Default <code>photos</code> <p>list of file paths to import</p> required <code>skip_duplicate_check</code> <p>if True, Photos will not check for duplicates on import, default is False</p> <code>False</code> <p>Returns:</p> Type Description <p>list of Photo objects for imported photos</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def import_photos(self, photo_paths, skip_duplicate_check=False):\n    \"\"\"import photos\n\n    Args:\n        photos: list of file paths to import\n        skip_duplicate_check: if True, Photos will not check for duplicates on import, default is False\n\n    Returns:\n        list of Photo objects for imported photos\n    \"\"\"\n    library = PhotosLibrary()\n    return library.import_photos(\n        photo_paths, album=self, skip_duplicate_check=skip_duplicate_check\n    )\n</code></pre>"},{"location":"reference/#photoscript.Album.path_str","title":"<code>path_str(delim='/')</code>","text":"<p>Return internal library path to album as string.     e.g. \"Folder/SubFolder/AlbumName\"</p> <p>Parameters:</p> Name Type Description Default <code>delim</code> <p>character to use as delimiter between path elements; default is \"/\"</p> <code>'/'</code> Source code in <code>photoscript/__init__.py</code> <pre><code>def path_str(self, delim=\"/\"):\n    \"\"\"Return internal library path to album as string.\n        e.g. \"Folder/SubFolder/AlbumName\"\n\n    Args:\n        delim: character to use as delimiter between path elements; default is \"/\"\n\n    Raises:\n        ValueError if delim is not a single character\n    \"\"\"\n    if len(delim) &gt; 1:\n        raise ValueError(\"delim must be single character\")\n\n    return run_script(\"albumGetPath\", self.id, delim)\n</code></pre>"},{"location":"reference/#photoscript.Album.photos","title":"<code>photos()</code>","text":"<p>list of Photo objects for photos contained in album</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def photos(self):\n    \"\"\"list of Photo objects for photos contained in album\"\"\"\n    photo_ids = run_script(\"albumPhotes\", self.id)\n    return [Photo(uuid) for uuid in photo_ids]\n</code></pre>"},{"location":"reference/#photoscript.Album.remove","title":"<code>remove(photos)</code>","text":"<p>Remove photos from album.     Note: Photos does not provide a way to remove photos from an album via AppleScript.     This method actually creates a new Album with the same name as the original album and     copies all photos from original album with exception of those to remove to the new album     then deletes the old album.</p> <p>Parameters:</p> Name Type Description Default <code>photos</code> <p>list of Photo objects to remove</p> required <p>Returns:</p> Type Description <p>new Album object for the new album with photos removed.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def remove(self, photos):\n    \"\"\"Remove photos from album.\n        Note: Photos does not provide a way to remove photos from an album via AppleScript.\n        This method actually creates a new Album with the same name as the original album and\n        copies all photos from original album with exception of those to remove to the new album\n        then deletes the old album.\n\n    Args:\n        photos: list of Photo objects to remove\n\n    Returns:\n        new Album object for the new album with photos removed.\n    \"\"\"\n    photo_uuids = [photo.id for photo in photos]\n    return self.remove_by_id(photo_uuids)\n</code></pre>"},{"location":"reference/#photoscript.Album.remove_by_id","title":"<code>remove_by_id(photo_ids)</code>","text":"<p>Remove photos from album.     Note: Photos does not provide a way to remove photos from an album via AppleScript.     This method actually creates a new Album with the same name as the original album and     copies all photos from original album with exception of those to remove to the new album     then deletes the old album.</p> <p>Parameters:</p> Name Type Description Default <code>photo_ids</code> <p>list of photo ids to remove</p> required <p>Returns:</p> Type Description <p>new Album object for the new album with photos removed.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def remove_by_id(self, photo_ids):\n    \"\"\"Remove photos from album.\n        Note: Photos does not provide a way to remove photos from an album via AppleScript.\n        This method actually creates a new Album with the same name as the original album and\n        copies all photos from original album with exception of those to remove to the new album\n        then deletes the old album.\n\n    Args:\n        photo_ids: list of photo ids to remove\n\n    Returns:\n        new Album object for the new album with photos removed.\n    \"\"\"\n    photoslib = PhotosLibrary()\n    new_album = photoslib.create_album(\n        photoslib._temp_album_name(), folder=self.parent\n    )\n    old_photos = self.photos()\n    new_photo_uuids = [\n        photo.id for photo in old_photos if photo.id not in photo_ids\n    ]\n    new_photos = [Photo(uuid) for uuid in new_photo_uuids]\n    if new_photos:\n        new_album.add(new_photos)\n    name = self.name\n    photoslib.delete_album(self)\n    new_album.name = name\n    self.id = new_album.id\n    self._uuid = new_album.uuid\n    return new_album\n</code></pre>"},{"location":"reference/#photoscript.Album.spotlight","title":"<code>spotlight()</code>","text":"<p>spotlight the album in Photos</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def spotlight(self):\n    \"\"\"spotlight the album in Photos\"\"\"\n    run_script(\"albumSpotlight\", self.id)\n</code></pre>"},{"location":"reference/#folder","title":"Folder","text":"Source code in <code>photoscript/__init__.py</code> <pre><code>class Folder:\n    def __init__(\n        self,\n        uuid: str | None = None,\n        path: list[str] | None = None,\n        idstring: str | None = None,\n    ):\n        \"\"\"Create a Folder object; only one of path, uuid, or idstring should be specified\n\n        The preferred method is to use the path argument or idstring to specify the folder\n        as this is much faster than using uuid.  The uuid argument is listed first for\n        backwards compatibility.\n\n        Args:\n            path: list of folder names in descending order from parent to child: [\"Folder\", \"SubFolder\"]\n            uuid: uuid of folder: \"E0CD4B6C-CB43-46A6-B8A3-67D1FB4D0F3D/L0/020\" or \"E0CD4B6C-CB43-46A6-B8A3-67D1FB4D0F3D\"\n            idstring: idstring of folder:\n                \"folder id(\\\"E0CD4B6C-CB43-46A6-B8A3-67D1FB4D0F3D/L0/020\\\") of folder id(\\\"CB051A4C-2CB7-4B90-B59B-08CC4D0C2823/L0/020\\\")\"\n        \"\"\"\n        if sum(bool(x) for x in (path, uuid, idstring)) != 1:\n            raise ValueError(\n                \"One (and only one) of path, uuid, or idstring must be specified\"\n            )\n\n        if uuid is not None:\n            uuid, _id = uuid_to_id(uuid, UUID_SUFFIX_FOLDER)\n        else:\n            _id = None\n\n        self._path, self._uuid, self._id, self._idstring = path, uuid, _id, idstring\n\n        # if initialized with path or uuid, need to initialize idstring\n        if self._path is not None:\n            self._idstring = run_script(\"folderGetIDStringFromPath\", self._path)\n            if self._idstring == kMissingValue:\n                raise ValueError(f\"Folder at path {self._path} does not exist\")\n        elif self._id is not None:\n            # if uuid was passed, _id will have been initialized above\n            # second argument is False so search is not limited to top-level folders\n            self._idstring = run_script(\n                \"photosLibraryGetFolderIDStringForID\", self._id, False\n            )\n            if self._idstring == kMissingValue:\n                raise ValueError(f\"Folder id {self._id} does not exist\")\n\n        if not run_script(\"folderExists\", self._idstring):\n            raise ValueError(f\"Folder {self._idstring} does not exist\")\n\n    @property\n    def idstring(self) -&gt; str:\n        \"\"\"idstring of folder\"\"\"\n        return self._idstring\n\n    @property\n    def uuid(self):\n        \"\"\"UUID of folder\"\"\"\n        if self._uuid is not None:\n            return self._uuid\n        self._uuid, self._id = uuid_to_id(\n            run_script(\"folderUUID\", self._idstring), UUID_SUFFIX_FOLDER\n        )\n        return self._uuid\n\n    @property\n    def id(self):\n        \"\"\"ID of folder\"\"\"\n        if self._id is not None:\n            return self._id\n        self._uuid, self._id = uuid_to_id(\n            run_script(\"folderUUID\", self._idstring), UUID_SUFFIX_FOLDER\n        )\n        return self._id\n\n    @property\n    def name(self):\n        \"\"\"name of folder (read/write)\"\"\"\n        name = run_script(\"folderName\", self._idstring)\n        return name if name != kMissingValue else \"\"\n\n    @name.setter\n    def name(self, name):\n        \"\"\"set name of photo\"\"\"\n        name = \"\" if name is None else name\n        return run_script(\"folderSetName\", self._idstring, name)\n\n    @property\n    def title(self):\n        \"\"\"title of folder (alias for Folder.name)\"\"\"\n        return self.name\n\n    @title.setter\n    def title(self, title):\n        \"\"\"set title of folder (alias for name)\"\"\"\n        name = \"\" if title is None else title\n        return run_script(\"folderSetName\", self._idstring, name)\n\n    @property\n    def parent_id(self):\n        \"\"\"parent container id string\"\"\"\n        parent_id = run_script(\"folderParent\", self._idstring)\n        return parent_id if parent_id != kMissingValue else None\n\n    # TODO: if no parent should return a \"My Albums\" object that contains all top-level folders/albums?\n    @property\n    def parent(self):\n        \"\"\"Return parent Folder object\"\"\"\n        parent_idstring = self.parent_id\n        return Folder(idstring=parent_idstring) if parent_idstring is not None else None\n\n    def path_str(self, delim=\"/\"):\n        \"\"\"Return internal library path to folder as string.\n            e.g. \"Folder/SubFolder\"\n\n        Args:\n            delim: character to use as delimiter between path elements; default is \"/\"\n\n        Raises:\n            ValueError if delim is not a single character\n        \"\"\"\n        if len(delim) &gt; 1:\n            raise ValueError(\"delim must be single character\")\n\n        return run_script(\"folderGetPath\", self._idstring, delim)\n\n    def path(self):\n        \"\"\"Return list of Folder objects this folder is contained in.\n        path()[0] is the top-level folder this folder is contained in and\n        path()[-1] is the immediate parent of this folder.  Returns empty\n        list if folder is not contained in another folders.\n        \"\"\"\n        folder_path = run_script(\"folderGetPathFolderIDScript\", self._idstring)\n        return [Folder(idstring=folder) for folder in folder_path]\n\n    @property\n    def albums(self):\n        \"\"\"list of Album objects for albums contained in folder\"\"\"\n        album_ids = run_script(\"folderAlbums\", self._idstring)\n        return [Album(uuid) for uuid in album_ids]\n\n    def album(self, name):\n        \"\"\"Return Album object contained in this folder for album named name\n        or None if no matching album\n        \"\"\"\n        return next((album for album in self.albums if album.name == name), None)\n\n    @property\n    def subfolders(self):\n        \"\"\"list of Folder objects for immediate sub-folders contained in folder\"\"\"\n        folder_idstrings = run_script(\"folderFolders\", self._idstring)\n        return [Folder(idstring=ids) for ids in folder_idstrings]\n\n    def folder(self, name):\n        \"\"\"Folder object for first subfolder folder named name.\n\n        Args:\n            name: name of folder to to return\n\n        Returns:\n            Folder object for first subfolder who's name matches name or None if not found\n        \"\"\"\n        return next((folder for folder in self.subfolders if folder.name == name), None)\n\n    def create_album(self, name: str) -&gt; \"Album\":\n        \"\"\"Creates an album in this folder\n\n        Args:\n            name: name of new album\n\n        Returns:\n            Album object for newly created album\n        \"\"\"\n        return PhotosLibrary().create_album(name=name, folder=self)\n\n    def create_folder(self, name: str) -&gt; \"Folder\":\n        \"\"\"creates a folder in this folder\n\n        Returns:\n            Folder object for newly created folder\n        \"\"\"\n        return PhotosLibrary().create_folder(name=name, folder=self)\n\n    def spotlight(self):\n        \"\"\"spotlight the folder in Photos\"\"\"\n        run_script(\"folderSpotlight\", self._idstring)\n\n    def __len__(self):\n        return run_script(\"folderCount\", self._idstring)\n</code></pre>"},{"location":"reference/#photoscript.Folder.albums","title":"<code>albums</code>  <code>property</code>","text":"<p>list of Album objects for albums contained in folder</p>"},{"location":"reference/#photoscript.Folder.id","title":"<code>id</code>  <code>property</code>","text":"<p>ID of folder</p>"},{"location":"reference/#photoscript.Folder.idstring","title":"<code>idstring: str</code>  <code>property</code>","text":"<p>idstring of folder</p>"},{"location":"reference/#photoscript.Folder.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>name of folder (read/write)</p>"},{"location":"reference/#photoscript.Folder.parent","title":"<code>parent</code>  <code>property</code>","text":"<p>Return parent Folder object</p>"},{"location":"reference/#photoscript.Folder.parent_id","title":"<code>parent_id</code>  <code>property</code>","text":"<p>parent container id string</p>"},{"location":"reference/#photoscript.Folder.subfolders","title":"<code>subfolders</code>  <code>property</code>","text":"<p>list of Folder objects for immediate sub-folders contained in folder</p>"},{"location":"reference/#photoscript.Folder.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>title of folder (alias for Folder.name)</p>"},{"location":"reference/#photoscript.Folder.uuid","title":"<code>uuid</code>  <code>property</code>","text":"<p>UUID of folder</p>"},{"location":"reference/#photoscript.Folder.__init__","title":"<code>__init__(uuid=None, path=None, idstring=None)</code>","text":"<p>Create a Folder object; only one of path, uuid, or idstring should be specified</p> <p>The preferred method is to use the path argument or idstring to specify the folder as this is much faster than using uuid.  The uuid argument is listed first for backwards compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>list[str] | None</code> <p>list of folder names in descending order from parent to child: [\"Folder\", \"SubFolder\"]</p> <code>None</code> <code>uuid</code> <code>str | None</code> <p>uuid of folder: \"E0CD4B6C-CB43-46A6-B8A3-67D1FB4D0F3D/L0/020\" or \"E0CD4B6C-CB43-46A6-B8A3-67D1FB4D0F3D\"</p> <code>None</code> <code>idstring</code> <code>str | None</code> <p>idstring of folder: \"folder id(\"E0CD4B6C-CB43-46A6-B8A3-67D1FB4D0F3D/L0/020\") of folder id(\"CB051A4C-2CB7-4B90-B59B-08CC4D0C2823/L0/020\")\"</p> <code>None</code> Source code in <code>photoscript/__init__.py</code> <pre><code>def __init__(\n    self,\n    uuid: str | None = None,\n    path: list[str] | None = None,\n    idstring: str | None = None,\n):\n    \"\"\"Create a Folder object; only one of path, uuid, or idstring should be specified\n\n    The preferred method is to use the path argument or idstring to specify the folder\n    as this is much faster than using uuid.  The uuid argument is listed first for\n    backwards compatibility.\n\n    Args:\n        path: list of folder names in descending order from parent to child: [\"Folder\", \"SubFolder\"]\n        uuid: uuid of folder: \"E0CD4B6C-CB43-46A6-B8A3-67D1FB4D0F3D/L0/020\" or \"E0CD4B6C-CB43-46A6-B8A3-67D1FB4D0F3D\"\n        idstring: idstring of folder:\n            \"folder id(\\\"E0CD4B6C-CB43-46A6-B8A3-67D1FB4D0F3D/L0/020\\\") of folder id(\\\"CB051A4C-2CB7-4B90-B59B-08CC4D0C2823/L0/020\\\")\"\n    \"\"\"\n    if sum(bool(x) for x in (path, uuid, idstring)) != 1:\n        raise ValueError(\n            \"One (and only one) of path, uuid, or idstring must be specified\"\n        )\n\n    if uuid is not None:\n        uuid, _id = uuid_to_id(uuid, UUID_SUFFIX_FOLDER)\n    else:\n        _id = None\n\n    self._path, self._uuid, self._id, self._idstring = path, uuid, _id, idstring\n\n    # if initialized with path or uuid, need to initialize idstring\n    if self._path is not None:\n        self._idstring = run_script(\"folderGetIDStringFromPath\", self._path)\n        if self._idstring == kMissingValue:\n            raise ValueError(f\"Folder at path {self._path} does not exist\")\n    elif self._id is not None:\n        # if uuid was passed, _id will have been initialized above\n        # second argument is False so search is not limited to top-level folders\n        self._idstring = run_script(\n            \"photosLibraryGetFolderIDStringForID\", self._id, False\n        )\n        if self._idstring == kMissingValue:\n            raise ValueError(f\"Folder id {self._id} does not exist\")\n\n    if not run_script(\"folderExists\", self._idstring):\n        raise ValueError(f\"Folder {self._idstring} does not exist\")\n</code></pre>"},{"location":"reference/#photoscript.Folder.album","title":"<code>album(name)</code>","text":"<p>Return Album object contained in this folder for album named name or None if no matching album</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def album(self, name):\n    \"\"\"Return Album object contained in this folder for album named name\n    or None if no matching album\n    \"\"\"\n    return next((album for album in self.albums if album.name == name), None)\n</code></pre>"},{"location":"reference/#photoscript.Folder.create_album","title":"<code>create_album(name)</code>","text":"<p>Creates an album in this folder</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of new album</p> required <p>Returns:</p> Type Description <code>'Album'</code> <p>Album object for newly created album</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def create_album(self, name: str) -&gt; \"Album\":\n    \"\"\"Creates an album in this folder\n\n    Args:\n        name: name of new album\n\n    Returns:\n        Album object for newly created album\n    \"\"\"\n    return PhotosLibrary().create_album(name=name, folder=self)\n</code></pre>"},{"location":"reference/#photoscript.Folder.create_folder","title":"<code>create_folder(name)</code>","text":"<p>creates a folder in this folder</p> <p>Returns:</p> Type Description <code>'Folder'</code> <p>Folder object for newly created folder</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def create_folder(self, name: str) -&gt; \"Folder\":\n    \"\"\"creates a folder in this folder\n\n    Returns:\n        Folder object for newly created folder\n    \"\"\"\n    return PhotosLibrary().create_folder(name=name, folder=self)\n</code></pre>"},{"location":"reference/#photoscript.Folder.folder","title":"<code>folder(name)</code>","text":"<p>Folder object for first subfolder folder named name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>name of folder to to return</p> required <p>Returns:</p> Type Description <p>Folder object for first subfolder who's name matches name or None if not found</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def folder(self, name):\n    \"\"\"Folder object for first subfolder folder named name.\n\n    Args:\n        name: name of folder to to return\n\n    Returns:\n        Folder object for first subfolder who's name matches name or None if not found\n    \"\"\"\n    return next((folder for folder in self.subfolders if folder.name == name), None)\n</code></pre>"},{"location":"reference/#photoscript.Folder.path","title":"<code>path()</code>","text":"<p>Return list of Folder objects this folder is contained in. path()[0] is the top-level folder this folder is contained in and path()[-1] is the immediate parent of this folder.  Returns empty list if folder is not contained in another folders.</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def path(self):\n    \"\"\"Return list of Folder objects this folder is contained in.\n    path()[0] is the top-level folder this folder is contained in and\n    path()[-1] is the immediate parent of this folder.  Returns empty\n    list if folder is not contained in another folders.\n    \"\"\"\n    folder_path = run_script(\"folderGetPathFolderIDScript\", self._idstring)\n    return [Folder(idstring=folder) for folder in folder_path]\n</code></pre>"},{"location":"reference/#photoscript.Folder.path_str","title":"<code>path_str(delim='/')</code>","text":"<p>Return internal library path to folder as string.     e.g. \"Folder/SubFolder\"</p> <p>Parameters:</p> Name Type Description Default <code>delim</code> <p>character to use as delimiter between path elements; default is \"/\"</p> <code>'/'</code> Source code in <code>photoscript/__init__.py</code> <pre><code>def path_str(self, delim=\"/\"):\n    \"\"\"Return internal library path to folder as string.\n        e.g. \"Folder/SubFolder\"\n\n    Args:\n        delim: character to use as delimiter between path elements; default is \"/\"\n\n    Raises:\n        ValueError if delim is not a single character\n    \"\"\"\n    if len(delim) &gt; 1:\n        raise ValueError(\"delim must be single character\")\n\n    return run_script(\"folderGetPath\", self._idstring, delim)\n</code></pre>"},{"location":"reference/#photoscript.Folder.spotlight","title":"<code>spotlight()</code>","text":"<p>spotlight the folder in Photos</p> Source code in <code>photoscript/__init__.py</code> <pre><code>def spotlight(self):\n    \"\"\"spotlight the folder in Photos\"\"\"\n    run_script(\"folderSpotlight\", self._idstring)\n</code></pre>"}]}